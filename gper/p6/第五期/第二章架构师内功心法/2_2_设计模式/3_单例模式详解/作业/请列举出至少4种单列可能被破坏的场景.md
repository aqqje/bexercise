饿汉式单例模式在类加载时初始化并创建对象（通常由静态方法或静态代码块实现），在线程出现之前即完成了对象的创建，故线程安全；但饿汉式单例模式可能被反射破坏；

1、多线程并发：普通懒汉式单例模式在对象被调用时才创建，故不加锁的多线程情况下可能会出现线程安全问题；

**解决方法**：利用**双重检查锁懒汉式单例模式**可以解决通常情况下的多线程造成的懒汉式单例的线程安全问题；
2、克隆：clone()方法为Object类的方法，利用clone()直接克隆一个单例对象即破坏了单例对象的唯一性；

**解决方法**:使用clone()方法时需实现cloneable()接口,所以单例模式的类不实现该接口即可避免被克隆破坏单例模式；
3、反射机制：
1>利用反射可以获取构造方法，强制访问并暴力初始化多次，即可获得多个不同的单例对象；
2>反射机制同样可以破坏饿汉式单例模式；

**解决方法**：在双重检查锁懒汉式单例模式中的构造方法中校验已经创建与否（同 枚举类单例）后可以解决由反射创建对象造成的线程安全问题；由于枚举类在java底层即规定不允许被反射机制创建，故可以避免被反射机制暴力破坏单例模式，此方式相当于创建对象时使用了饿汉式单例，故可能产生内存浪费；
4、序列化对象：当单例对象需要序列化存盘并反序列化为对象时会重新分配内存地址，相当于重新创建了对象；

**解决方法**：给单例对象添加**readResolve()**方法，反序列化执行过程中会执行到ObjectInputStream.readOrdinaryObject()方法，该方法会判断对象是否包含readResolve方法，若包含此方法则调用该方法获得对象实例；
5、ThreadLocal单例（局限性单例）：ThreadLocal 为每个线程都拥有一个独立的map维护对象的实例，故天生本身就是线程安全的，但出了自己的线程就不是单例了。

